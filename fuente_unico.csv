"abrir_csv_individuales","(archivos)","m_csv_finales.py","diccionario_archivos_abiertos = {}","for archivo, nombre_modulo in archivos:","if nombre_modulo not in diccionario_archivos_abiertos:","diccionario_archivos_abiertos[nombre_modulo] = {'contenido': None, 'lineas': []}","diccionario_archivos_abiertos[nombre_modulo]['contenido'] = open(archivo, 'r')","return diccionario_archivos_abiertos"
"actualizar_diccionario_autores","(datos_por_autores, nombre_funcion, lineas_funcion, autor_funcion, indice_copia)","m_organizar_datos.py","if autor_funcion not in datos_por_autores:","datos_por_autores[autor_funcion] = {'lineas_totales': 0, 'funciones': {}}","if nombre_funcion not in datos_por_autores[autor_funcion]['funciones']:","datos_por_autores[autor_funcion]['funciones'][nombre_funcion] = -1","if nombre_funcion in datos_por_autores[autor_funcion]['funciones']:","datos_por_autores[autor_funcion]['funciones'][nombre_funcion] = len(lineas_funcion)","datos_por_autores[autor_funcion]['lineas_totales'] += len(lineas_funcion)","return datos_por_autores, indice_copia"
"actualizar_diccionario_funciones","(datos_por_funciones, nombre_funcion, parametros_funcion, modulo_funcion, lineas_funcion, autor_funcion, ayuda_funcion, otros_c, indice_copia)","m_organizar_datos.py","if nombre_funcion not in datos_por_funciones:","datos_por_funciones[nombre_funcion] = {'parametros': None,","'modulo': None,","'lineas': None,","'cantidad_lineas': 0,","'invocaciones': [],","'cantidad_invocaciones': 0,","'cantidad_parametros': 0,","'cantidad_comentarios': len(otros_c),","}","elif nombre_funcion in datos_por_funciones:","if f'{nombre_funcion}_{indice_copia-1}' in datos_por_funciones:","nombre_funcion += f'_{indice_copia}'","else:","indice_copia = 0","nombre_funcion += f'_{indice_copia}'","indice_copia += 1","datos_por_funciones[nombre_funcion] = {'parametros': None,","'modulo': None,","'lineas': None,","'cantidad_lineas': 0,","'invocaciones': [],","'cantidad_invocaciones': 0,","'cantidad_parametros': 0,","'cantidad_comentarios': len(otros_c),","}","datos_por_funciones[nombre_funcion]['parametros'] = parametros_funcion if len(parametros_funcion) > 2 else None","datos_por_funciones[nombre_funcion]['modulo'] = modulo_funcion","datos_por_funciones[nombre_funcion]['lineas'] = lineas_funcion","datos_por_funciones[nombre_funcion]['cantidad_lineas'] = len(lineas_funcion)","datos_por_funciones[nombre_funcion]['cantidad_parametros'] = len(parametros_funcion.split(',')) if parametros_funcion else 0","if 'comentarios' not in datos_por_funciones[nombre_funcion]:","datos_por_funciones[nombre_funcion]['comentarios'] = {'autor': None,","'ayuda': None,","'otros': None}","datos_por_funciones[nombre_funcion]['comentarios']['autor'] = autor_funcion","datos_por_funciones[nombre_funcion]['comentarios']['ayuda'] = ayuda_funcion.replace('',\n', '') if ('Ayuda' in ayuda_funcion) else None","datos_por_funciones[nombre_funcion]['comentarios']['otros'] = otros_c if len(otros_c) > 0 else None","if 'cantidad_decalraciones' not in datos_por_funciones[nombre_funcion]:","datos_por_funciones[nombre_funcion]['cantidad_declaraciones'] = {'returns': 0,","'if/elif': 0,","'for': 0,","'while': 0,","'break': 0,","'exit': 0,","}","obtener.cantidad_declaraciones(datos_por_funciones, lineas_funcion, nombre_funcion)","return datos_por_funciones, indice_copia"
"analizar_linea_funcion","(linea_codigo, nombre_modulo, info_ubicaciones, lineas_a_grabar, banderas, cadenas, info_lineas, lineas_fuera_funcion)","m_csv_individuales.py","if banderas[1]:","if 'Ayuda' in linea_codigo and not banderas[2]:","info_lineas[2], banderas[2] = analizar_linea.ayuda_funcion(linea_codigo, banderas[2])","if ''''\n' in linea_codigo or ''''\n' in linea_codigo:","banderas[1] = False","banderas[2] = False","elif linea_codigo[0:3] == 'def':","lineas_a_grabar, cadenas, banderas, info_lineas = resetear_por_inicio(linea_codigo, nombre_modulo, lineas_a_grabar, cadenas, banderas, info_lineas, info_ubicaciones)","elif linea_codigo.strip().startswith('return'):","lineas_a_grabar, cadenas, banderas, info_lineas = resetear_por_fin(linea_codigo, lineas_a_grabar, cadenas, banderas, info_lineas)","elif '#' in linea_codigo and not(''#' in linea_codigo or '('#' in linea_codigo) and '#todo' not in linea_codigo:","cadenas, banderas, info_lineas = guardar_comentario_numeral(linea_codigo, cadenas, banderas, info_lineas)","elif linea_codigo.strip().startswith(''''['):","banderas, info_lineas = guardar_comentario_multilinea(linea_codigo, banderas, info_lineas)","else:","if linea_codigo[0].isalpha():","lineas_fuera_funcion.append(linea_codigo.strip())","elif linea_codigo.strip() != '':","cadenas[0] += f','{linea_codigo.strip()}''","return lineas_a_grabar, banderas, cadenas, info_lineas, lineas_fuera_funcion"
"analizar_linea_modulo","(linea_codigo, nombre_modulo, info_ubicaciones, lineas_a_grabar, banderas, cadenas, info_lineas, lineas_fuera_funcion)","m_csv_individuales.py","if banderas[0]:","lineas_a_grabar, banderas, cadenas, info_lineas, lineas_fuera_funcion = analizar_linea_funcion(linea_codigo, nombre_modulo, info_ubicaciones, lineas_a_grabar, banderas, cadenas, info_lineas, lineas_fuera_funcion)","elif linea_codigo[0:3] == 'def':","cadenas, banderas, info_lineas, info_ubicaciones = formatear_declaracion_funcion(linea_codigo, nombre_modulo, cadenas, banderas, info_lineas, info_ubicaciones)","else:","lineas_fuera_funcion.append(linea_codigo.strip())","banderas[1] = banderas[2] = False","return lineas_a_grabar, banderas, cadenas, info_lineas, lineas_fuera_funcion"
"analizar_opcion","(datos_csv, opcion)","m_consulta_funciones.py","if opcion[0] == '#' and len(opcion) > 1:","opcion_numeral(datos_csv, opcion)","elif opcion[0] == '?' and len(opcion) > 1:","opcion_pregunta(datos_csv, opcion)","elif opcion == 'imprimir ?todo':","print('\nCreando archivo de ayuda...')","crear_ayuda_txt(datos_csv, opcion)","print('Archivo creado con exito!')","#Si se ingresa la opcion 'imprimir #todo' se crea el archivo de ayuda","elif opcion == 'imprimir #todo':","print('\nCreando archivo de ayuda...')","crear_ayuda_txt(datos_csv, opcion)","print('Archivo creado con exito!')","else:","print('\nOpcion incorrecta, ingrese nuevamente\n')"
"analizar_reutilizacion","(datos_por_funciones)","m_analizador_reutilizacion_codigo.py","diccionario_invocaciones, tupla_funciones, largo_maximo = buscar_invocaciones(datos_por_funciones)","diccionario_invocaciones = contar_interacciones(diccionario_invocaciones, tupla_funciones, datos_por_funciones)","filas_txt = creacion_formato_tabla(diccionario_invocaciones, largo_maximo)","filas_txt = asignacion_valores_tabla(filas_txt, diccionario_invocaciones)","creacion_archivo_txt(filas_txt)"
"asignacion_valores_tabla","(filas_txt, diccionario_invocaciones)","m_analizador_reutilizacion_codigo.py","for numero in diccionario_invocaciones :","if str(numero).isdigit() :","funcion_en_linea = diccionario_invocaciones['nombres'][numero]","for funcion in diccionario_invocaciones[numero][funcion_en_linea]:","if diccionario_invocaciones[numero][funcion_en_linea][funcion] > 0 :","filas_txt[numero] +=(f' {diccionario_invocaciones[numero][funcion_en_linea][funcion]} ')","else:","indice = diccionario_invocaciones['indices'][funcion]","if diccionario_invocaciones[indice][funcion][funcion_en_linea] > 0  :","filas_txt[numero] += (' X ')","else :","filas_txt[numero] += ('   ')","if 9 < numero < 100 :","filas_txt[numero] += ' '","elif numero >= 100 :","filas_txt[numero] += '  '","return filas_txt"
"autor_funcion","(linea_codigo, bandera_autor = False)","m_analizar_linea.py","autor_funcion = ''","for caracter in linea_codigo.strip():","if caracter == ']' and bandera_autor:","bandera_autor = False","if bandera_autor:","autor_funcion += caracter","if caracter == '[' and ('Autor' in linea_codigo or 'Autores' in linea_codigo):","bandera_autor = True","return autor_funcion"
"ayuda_funcion","(linea_codigo, bandera_ayuda)","m_analizar_linea.py","ayuda_funcion = ''","for caracter in linea_codigo.strip():","if caracter == ']' and bandera_ayuda:","bandera_ayuda = False","if bandera_ayuda:","ayuda_funcion += caracter","if caracter == '[' and 'Ayuda' in linea_codigo:","bandera_ayuda = True","return ayuda_funcion, bandera_ayuda"
"borrar_csv_individuales","(nombres_archivos_csv_individuales)","m_csv_finales.py","for ubicacion_archivo_csv_individual in obtener.ubicaciones_archivos_csv_individuales(nombres_archivos_csv_individuales):","os.remove(ubicacion_archivo_csv_individual)"
"buscar_invocaciones","(datos_por_funciones)","m_analizador_reutilizacion_codigo.py","cuenta_lineas = 0","diccionario_invocaciones = {'total': {} , 'indices' : {} , 'nombres' : {} }","largo_maximo = 0","tupla_funciones = tuple(datos_por_funciones.keys())","for nombre_funcion in tupla_funciones :","cuenta_lineas += 1","if len(nombre_funcion) > largo_maximo :","largo_maximo = len(nombre_funcion)","diccionario_invocaciones [cuenta_lineas] = {}","diccionario_invocaciones [cuenta_lineas] [nombre_funcion] = {}","diccionario_invocaciones ['total'] [cuenta_lineas] = 0","diccionario_invocaciones ['indices'] [nombre_funcion] = cuenta_lineas","diccionario_invocaciones ['nombres'] [cuenta_lineas] = nombre_funcion","for funcion in tupla_funciones :","diccionario_invocaciones [cuenta_lineas] [nombre_funcion] [funcion] = 0","return diccionario_invocaciones , tupla_funciones , largo_maximo"
"cantidad_declaraciones","(datos_fuente, lineas_funcion, nombre_funcion)","m_obtener.py","for linea_funcion in lineas_funcion:","if 'for' in linea_funcion:","datos_fuente[nombre_funcion]['cantidad_declaraciones']['for'] += linea_funcion.count('for')","if 'return' in linea_funcion:","datos_fuente[nombre_funcion]['cantidad_declaraciones']['returns'] += 1","if 'if' in linea_funcion:","datos_fuente[nombre_funcion]['cantidad_declaraciones']['if/elif'] += 1","elif 'elif' in linea_funcion:","datos_fuente[nombre_funcion]['cantidad_declaraciones']['if/elif'] += 1","elif 'while' in linea_funcion:","datos_fuente[nombre_funcion]['cantidad_declaraciones']['while'] += 1","elif 'break' in linea_funcion:","datos_fuente[nombre_funcion]['cantidad_declaraciones']['break'] += 1","elif 'exit' in linea_funcion:","datos_fuente[nombre_funcion]['cantidad_declaraciones']['exit'] += 1","return datos_fuente"
"cantidad_invocaciones","(datos, archivo_fuente)","m_obtener.py","for funcion in datos:","for linea_funcion in datos[funcion]['lineas']:","for nombre_funcion in datos:","if 'cantidad_invocaciones' not in datos[nombre_funcion]:","datos[nombre_funcion]['cantidad_invocaciones'] = 0","if (f'{nombre_funcion}(' in linea_funcion or f'{nombre_funcion[:-2]}(' in linea_funcion) and (not f'_{nombre_funcion}' in linea_funcion):","datos[nombre_funcion]['cantidad_invocaciones'] += 1","datos[funcion]['invocaciones'].append(nombre_funcion)","elif (f'{datos[nombre_funcion]['modulo']}.{nombre_funcion}(' in linea_funcion) or (f'{datos[nombre_funcion]['modulo']}.{nombre_funcion[:-2]}(' in linea_funcion):","datos[nombre_funcion]['cantidad_invocaciones'] += 1","datos[funcion]['invocaciones'].append(nombre_funcion)","return datos"
"cerrar_csv_individuales","(datos)","m_csv_finales.py","for nombre_modulo in datos:","datos[nombre_modulo]['contenido'].close()"
"comentario_numeral","(linea_codigo, bandera_otro_comentario = False, bandera_linea = True)","m_analizar_linea.py","otro_comentario = ''","posible_linea = ''","i = 0","linea = linea_codigo.strip()","if not linea_codigo.startswith('#'):","while i < len(linea):","if linea[i] == '#':","bandera_linea = False","bandera_otro_comentario = True","if bandera_linea:","posible_linea += linea[i]","if bandera_otro_comentario:","otro_comentario += linea[i]","i += 1","else:","otro_comentario = linea_codigo","return otro_comentario, posible_linea"
"consultar_funciones","(datos_archivos_csv)","m_consulta_funciones.py","lista_funciones = sorted(datos_archivos_csv.keys())","tabla, cantidad_guiones = obtener.tabla_funciones(lista_funciones)","mostrar_tabla_funciones(tabla, cantidad_guiones)","mostrar_instrucciones_uso()","solicitar_ingreso_usuario(datos_archivos_csv)"
"contar_interacciones","(diccionario_invocaciones, tupla_funciones, datos_por_funciones )","m_analizador_reutilizacion_codigo.py","lineas = 0","cuenta_linea = 0","while lineas < len(tupla_funciones) :","nombre = tupla_funciones [lineas]","cuenta_linea += 1","funciones_llamadas = datos_por_funciones[nombre]['invocaciones']","funcion_en_linea = diccionario_invocaciones['nombres'][cuenta_linea]","if cuenta_linea <= len(diccionario_invocaciones) :","for invocado in diccionario_invocaciones[cuenta_linea][funcion_en_linea] :","if invocado in funciones_llamadas :","diccionario_invocaciones [cuenta_linea][funcion_en_linea][invocado] += funciones_llamadas.count(invocado)","indices = diccionario_invocaciones ['indices'][invocado]","diccionario_invocaciones ['total'][indices] += funciones_llamadas.count(invocado)","lineas += 1","return diccionario_invocaciones"
"creacion_archivo_txt","(filas_txt)","m_analizador_reutilizacion_codigo.py","with open('analizador.txt' , 'w') as analizador :","for linea in filas_txt:","analizador.write(f'{linea}\n')","print(f'{linea}')"
"creacion_formato_tabla","(diccionario_invocaciones, largo_maximo)","m_analizador_reutilizacion_codigo.py","filas_txt = []","indice_de_lineas = 1","filas_txt.append(f'\t FUNCIONES\t{' '*(largo_maximo - 5)}')","cadena_totales = (f'\n\t Total Invocaciones{' ' * (largo_maximo-11)}')","for funcion in diccionario_invocaciones :","if str(funcion).isdigit() :","filas_txt [0] += (f' {funcion} ')","funcion_en_linea = diccionario_invocaciones['nombres'][funcion]","if '*' in funcion_en_linea :","funcion_en_linea = funcion_en_linea.replace('*','')","cadena_de_texto =  (f'\t {indice_de_lineas} {funcion_en_linea}\t{' ' * (largo_maximo-len(str(funcion_en_linea)) )}')","filas_txt.append(cadena_de_texto )","indice_de_lineas += 1","cadena_totales += (f' {diccionario_invocaciones ['total'] [funcion]} ')","if 9 < funcion < 100 :","cadena_totales += ' '","elif funcion >= 100 :","cadena_totales += '  '","filas_txt.append(cadena_totales)","return filas_txt"
"crear_ayuda_txt","(datos_csv, opcion)","m_consulta_funciones.py","with open('ayuda_funcion.txt', 'w') as archivo_ayuda:","for funcion in datos_csv:","grabar_ayuda_txt(archivo_ayuda, datos_csv, funcion, opcion)"
"crear_csv_finales","(nombre_archivo)","m_csv_finales.py","info_ubicaciones = obtener.informacion_ubicaciones(nombre_archivo)","archivos_fuente_individuales, archivos_comentarios_individuales, lineas_fuera_funcion = csv_individuales.crear_csv_individuales(info_ubicaciones)","merge('fuente_unico.csv', archivos_fuente_individuales, lineas_fuera_funcion)","merge('comentarios.csv', archivos_comentarios_individuales, lineas_fuera_funcion)","nombres_archivos_csv_individuales = list(zip(*(archivos_fuente_individuales+archivos_comentarios_individuales)))[0]","borrar_csv_individuales(nombres_archivos_csv_individuales)"
"crear_csv_individuales","(info_ubicaciones)","m_csv_individuales.py","archivos_fuente = [] ","archivos_comentarios = [] ","lineas_fuera_funcion = [] ","for ubicacion, nombre_modulo in info_ubicaciones:","with open(ubicacion, 'r', encoding='utf-8') as archivo_modulo, open(f'fuente_{nombre_modulo}.csv', 'w') as archivo_fuente, open(f'comentarios_{nombre_modulo}.csv', 'w') as archivo_comentarios:","lineas_a_grabar, lineas_fuera_funcion = leer_modulo(archivo_modulo, nombre_modulo, info_ubicaciones, lineas_fuera_funcion)","grabar_csv_individual(archivo_fuente, lineas_a_grabar[0])","grabar_csv_individual(archivo_comentarios, lineas_a_grabar[1])","archivos_fuente.append((f'fuente_{nombre_modulo}.csv', nombre_modulo))","archivos_comentarios.append((f'comentarios_{nombre_modulo}.csv', nombre_modulo))","return archivos_fuente, archivos_comentarios, lineas_fuera_funcion"
"crear_panel_general_csv","(lista_de_listas)","m_panel_general_funciones.py","with open('panel_general.csv', 'w') as archivo_panel_general:","grabar_panel_control_csv(archivo_panel_general, lista_de_listas)"
"crear_participacion_txt","(nombre_archivo, datos)","m_informacion_desarrollador.py","with open(nombre_archivo, 'w') as archivo_txt:","archivo_txt.write(datos)"
"declaracion_funcion","(line, bandera_nombre = True, bandera_parametro = False)","m_analizar_linea.py","nombre_funcion = ''","parametros_funcion = ''","for caracter in line[3:]:","if bandera_parametro:","parametros_funcion += caracter","if not caracter.isspace() and caracter != '(' and bandera_nombre:","nombre_funcion += caracter","elif caracter == '(':","parametros_funcion += caracter","bandera_nombre = False","bandera_parametro = True","elif caracter == ')':","bandera_parametro = False","return nombre_funcion, parametros_funcion"
"encontrar_main_archivo","(diccionario_informacion, funcion_main_dicc = None)","m_arbol_invocacion.py","lista_de_keys = list(diccionario_informacion.keys())","contador = 0","bandera = True","while (contador < len(lista_de_keys)) and bandera:","if lista_de_keys[contador].startswith('*'):","funcion_main_dicc = lista_de_keys[contador]","bandera = False","contador += 1","return funcion_main_dicc"
"formatear_datos_numeral","(datos_csv, funcion)","m_consulta_funciones.py","cadena_numeral = ''","cadena_numeral += f'{'*' * 79}\n'","cadena_numeral += f'Funcion: {funcion if '*' not in funcion else funcion[1:]}\n'","cadena_numeral += ('-' * len(f'Funcion: {funcion}') + '\n')","cadena_numeral += '\nInformacion:\n'","cadena_numeral += ('-' * len('Informacion:') + '\n')","if '*' in funcion:","cadena_numeral += 'Es la funcion principal\n'","cadena_numeral += f'Modulo: {datos_csv[funcion]['modulo'] if '*' not in datos_csv[funcion]['modulo'] else datos_csv[funcion]['modulo'][1:]}\n'","cadena_numeral += f'{datos_csv[funcion]['comentarios']['autor'] if 'Autor' in datos_csv[funcion]['comentarios']['autor'] else 'El autor es anonimo'}\n'","cadena_numeral += f'Ayuda: {'Si' if datos_csv[funcion]['comentarios']['ayuda'] else 'No brinda ayuda'}\n'","cadena_numeral += f'Parametros: {datos_csv[funcion]['cantidad_parametros']}\n'","cadena_numeral += f'Lineas de codigo: {datos_csv[funcion]['cantidad_lineas']}\n'","if datos_csv[funcion]['cantidad_comentarios'] > 0:","cadena_numeral += f'Comentarios: {datos_csv[funcion]['cantidad_comentarios']}\n'","else:","cadena_numeral += 'No aporta comentarios\n'","if datos_csv[funcion]['invocaciones']:","cadena_numeral += f'Invoca a {'(), '.join(datos_csv[funcion]['invocaciones'])}()\n'","else:","cadena_numeral += 'No invoca a ninguna funcion\n'","if datos_csv[funcion]['cantidad_invocaciones'] > 0:","cadena_numeral += f'Es invocada {datos_csv[funcion]['cantidad_invocaciones']} {'veces' if datos_csv[funcion]['cantidad_invocaciones'] > 1 else 'vez'}\n'","else:","cadena_numeral += 'No es invocada por ninguna funcion\n'","cadena_numeral += '\nCantidad de declaraciones: \n'","cadena_numeral += ('-' * len('Cantidad de declaraciones: ') + '\n')","for declaracion in datos_csv[funcion]['cantidad_declaraciones']:","cadena_numeral += f'{declaracion}: {datos_csv[funcion]['cantidad_declaraciones'][declaracion]}\n'","cadena_numeral += f'{'*' * 79}\n'","return cadena_numeral"
"formatear_datos_pregunta","(datos_csv, funcion)","m_consulta_funciones.py","candena_pregunta = ''","modulo = datos_csv[funcion]['modulo'] if '*' not in datos_csv[funcion]['modulo'] else datos_csv[funcion]['modulo'][1:]","autor = datos_csv[funcion]['comentarios']['autor']","candena_pregunta += f'{'*' * 79}\n'","candena_pregunta += f'Funcion: {funcion if '*' not in funcion else funcion[1:]}\n'","if datos_csv[funcion]['comentarios']['ayuda'] and (len(datos_csv[funcion]['comentarios']['ayuda']) > 80):","candena_pregunta += f'{analizar_linea.largo_linea(datos_csv[funcion]['comentarios']['ayuda'])}\n'","else:","candena_pregunta += 'No brinda ayuda\n'","if datos_csv[funcion]['parametros'] and (len('Parametros formales: ')+len(datos_csv[funcion]['parametros']) > 80):","candena_pregunta += f'{analizar_linea.largo_linea('Parametros formales: ' + datos_csv[funcion]['parametros'])}\n'","else:","candena_pregunta += 'No tiene parametros formales\n'","candena_pregunta += f'Modulo: {modulo}\n'","candena_pregunta += f'{autor if 'Autor' in autor else 'El autor es anonimo'}\n'","candena_pregunta += f'{'*' * 79}\n'","return candena_pregunta"
"formatear_declaracion_funcion","(linea_codigo, nombre_modulo, cadenas, banderas, info_lineas, info_ubicaciones)","m_csv_individuales.py","banderas[0] = True","banderas[1] = banderas[2] = False","info_lineas[0], param = analizar_linea.declaracion_funcion(linea_codigo)","if nombre_modulo == info_ubicaciones[0][1]:","cadenas[0] += f''{info_lineas[0]}','{param}','*{nombre_modulo}''","else:","cadenas[0] += f''{info_lineas[0]}','{param}','{nombre_modulo}''","return cadenas, banderas, info_lineas, info_ubicaciones"
"formatear_participacion","(datos_ordenados)","m_informacion_desarrollador.py","lineas_codigo_totales = sum(datos_autor['lineas_totales'] for _, datos_autor in datos_ordenados)","funciones_totales = 0","datos_a_imprimir = ''","datos_a_imprimir += '\t\tInformacion de Desarrollo Por Autor\n'","for autor, datos_autor in datos_ordenados:","lineas_totales_autor = datos_autor['lineas_totales']","columna_1 = 'Funcion'","columna_2 = 'Lineas'","separacion = ' ' * (50-len(columna_1))","separacion_2 = ' ' * 7","linea_iguales = f'{separacion_2}{'=' * (50 + len(columna_1))}'","datos_a_imprimir += f'\n{autor if 'Autor' in autor else 'Sin Autor'}\n\n{separacion_2}{columna_1}{separacion}{columna_2}\n'","datos_a_imprimir += f'{linea_iguales}\n'","for funcion, cantidad_lineas in datos_autor['funciones'].items():","separacion = ' ' * (50-len(funcion))","if '*' in funcion:","datos_a_imprimir += f'{separacion_2}{funcion[1:]}{separacion}{cantidad_lineas}\n'","else:","datos_a_imprimir += f'{separacion_2}{funcion}{separacion}{cantidad_lineas}\n'","porcentaje_lineas_autor = round(obtener.porcentaje_lineas_codigo(autor, datos_autor,  lineas_codigo_totales), 1)","funciones_totales += len(datos_autor['funciones'])","columna_1 = f'{len(datos_autor['funciones'])} Funciones - Lineas'","separacion = ' ' * (50-len(columna_1))","datos_a_imprimir += f'{separacion_2}{columna_1}{separacion}{lineas_totales_autor}\t{porcentaje_lineas_autor}%\n\n'","columna_1 = f'{funciones_totales} Funciones - Lineas'","separacion = ' ' * (50-len(columna_1))","datos_a_imprimir += f'Total: {columna_1}{separacion}{lineas_codigo_totales}'","return datos_a_imprimir"
"generar_tabla_panel_general","(diccionario)","m_panel_general_funciones.py","longitud = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]","columnas_titulo = ['Funcion', 'Parametros', 'Lineas', 'Invocaciones', 'Returns', 'If/Elif', 'For', 'While', 'Break', 'Exit', 'Coment', 'Ayuda', 'Autor']","longitud = obtener.longitud_maxima(columnas_titulo,longitud)","lista_de_listas = [columnas_titulo]","for funcion, datos_funcion in diccionario.items():","columnas_datos = [f'{funcion if not '*' in funcion else funcion[1:]}.{datos_funcion['modulo'] if not '*' in datos_funcion['modulo'] else datos_funcion['modulo'][1:]}',","f'{datos_funcion['cantidad_parametros']}', f'{datos_funcion['cantidad_lineas']}', f'{datos_funcion['cantidad_invocaciones']}',","f'{datos_funcion['cantidad_declaraciones']['returns']}', f'{datos_funcion['cantidad_declaraciones']['if/elif']}',","f'{datos_funcion['cantidad_declaraciones']['for']}', f'{datos_funcion['cantidad_declaraciones']['while']}',","f'{datos_funcion['cantidad_declaraciones']['break']}', f'{diccionario[funcion]['cantidad_declaraciones']['exit']}',","f'{datos_funcion['cantidad_comentarios']}', f'{'Si' if datos_funcion['comentarios']['ayuda'] else 'No'}',","f''{datos_funcion['comentarios']['autor'].split(': ')[1] if datos_funcion['comentarios']['autor'] else 'Sin Autor'}'']","lista_de_listas.append(columnas_datos)","longitud = obtener.longitud_maxima(columnas_datos,longitud)","return lista_de_listas, longitud"
"grabar_ayuda_txt","(archivo_ayuda, datos_csv, funcion, opcion)","m_consulta_funciones.py","if '?' in opcion:","informacion = formatear_datos_pregunta(datos_csv, funcion)","archivo_ayuda.write(informacion)","elif '#' in opcion:","informacion = formatear_datos_numeral(datos_csv, funcion)","archivo_ayuda.write(informacion)"
"grabar_csv_final_ordenado","(archivo_final, archivos_individuales, lineas_fuera_funcion)","m_csv_finales.py","obtener_primera_linea = lambda x: min(x)","lineas = leer_csv_individuales(archivos_individuales)","while lineas:","linea_menor = obtener_primera_linea(lineas)","for linea in lineas:","if linea == linea_menor:","funcion, _, modulo, *otros_datos = linea.split('','')","if '*' in modulo and (f'{funcion[1:]}()' in lineas_fuera_funcion or f'{funcion[1:]}()\n' in lineas_fuera_funcion):","archivo_final.write(''*' + linea[1:])","else:","archivo_final.write(linea)","lineas.remove(linea)"
"grabar_csv_individual","(archivo, lineas)","m_csv_individuales.py","for linea in lineas:","archivo.write(linea)"
"grabar_panel_control_csv","(archivo, lineas)","m_panel_general_funciones.py","for linea in lineas:","archivo.write(f'{','.join(linea)}\n')"
"grafica_arbol_invocaciones","(diccionario_informacion)","m_arbol_invocacion.py","obtener_arbol_invocaciones(diccionario_informacion)"
"guardar_comentario_multilinea","(linea_codigo, banderas, info_lineas)","m_csv_individuales.py","if linea_codigo.count(''''') == 2:","if 'Autor' in linea_codigo:","info_lineas[1] = analizar_linea.autor_funcion(linea_codigo)","elif 'Ayuda' in linea_codigo:","info_lineas[2] = linea_codigo[4:-4]","else:","if info_lineas[3] == '':","info_lineas[3] = f'{coment}'","else:","info_lineas[3] += f'','{coment}'","else:","banderas[1] = True","if 'Autor' in linea_codigo:","info_lineas[1] = analizar_linea.autor_funcion(linea_codigo)","return banderas, info_lineas"
"guardar_comentario_numeral","(linea_codigo, cadenas, banderas, info_lineas)","m_csv_individuales.py","coment, seudo_line = analizar_linea.comentario_numeral(linea_codigo)","if info_lineas[3] == '':","info_lineas[3] = f'{coment}'","else:","info_lineas[3] += f'','{coment}'","if seudo_line:","cadenas[0] += f','{seudo_line}''","banderas[1] = False","return cadenas, banderas, info_lineas"
"informacion_ubicaciones","(nombre_archivo)","m_obtener.py","ubicaciones = []","os = platform.system()","with open(nombre_archivo, 'r') as archivo_programas:","ubicacion = archivo_programas.readline().strip()","while ubicacion:","if os == 'Linux' or os == 'Darwin':","ubicaciones.append((ubicacion, ubicacion.split('/')[-1]))","elif os == 'Windows':","ubicaciones.append((ubicacion, ubicacion.split('\\')[-1]))","ubicacion = archivo_programas.readline().strip()","return ubicaciones"
"largo_linea","(ayuda)","m_analizar_linea.py","linea_recortada = ''","i = 0","while (i < len(ayuda)):","if( i % 78 == 0) and (i != 0):","if ayuda[i].isalpha():","linea_recortada += '-\n'","else:","linea_recortada += '\n'","linea_recortada += ayuda[i]","i += 1","return linea_recortada"
"leer_archivos_csv","(archivo_fuente, archivo_comentarios)","m_organizar_datos.py","datos_por_autores = {}","datos_por_funciones = {}","indice_copia = 0","linea_fuente = archivo_fuente.readline()","linea_comentarios = archivo_comentarios.readline()","while linea_fuente and linea_comentarios:","nombre_funcion_f, parametros_funcion, modulo_funcion, *lineas_funcion = linea_fuente.split('','')","nombre_funcion_c, autor_funcion, ayuda_funcion, *otros_c = linea_comentarios.split('','')","nombre_funcion = nombre_funcion_f = nombre_funcion_c = nombre_funcion_f.replace(''', '')","datos_por_funciones, indice_copia = actualizar_diccionario_funciones(datos_por_funciones, nombre_funcion, parametros_funcion, modulo_funcion, lineas_funcion, autor_funcion, ayuda_funcion, otros_c, indice_copia)","datos_por_autores, indice_copia = actualizar_diccionario_autores(datos_por_autores, nombre_funcion, lineas_funcion, autor_funcion, indice_copia)","linea_fuente = archivo_fuente.readline()","linea_comentarios = archivo_comentarios.readline()","obtener.cantidad_invocaciones(datos_por_funciones, archivo_fuente)","return datos_por_funciones, datos_por_autores"
"leer_csv_individuales","(datos)","m_csv_finales.py","lineas = []","for nombre_modulo in datos:","linea = datos[nombre_modulo]['contenido'].readline()","while linea:","lineas.append(linea)","linea = datos[nombre_modulo]['contenido'].readline()","return lineas"
"leer_modulo","(archivo_modulo, nombre_modulo, info_ubicaciones, lineas_fuera_funcion)","m_csv_individuales.py","lineas_a_grabar = [[],[]] ","banderas = [False, False, False] ","cadenas = ['',''] ","info_lineas = ['', '', '', ''] ","linea_codigo = archivo_modulo.readline().replace(''', ''')","while linea_codigo:","lineas_a_grabar, banderas, cadenas, info_lineas, lineas_fuera_funcion = analizar_linea_modulo(linea_codigo, nombre_modulo, info_ubicaciones, lineas_a_grabar, banderas, cadenas, info_lineas, lineas_fuera_funcion)","linea_codigo = archivo_modulo.readline().replace(''', ''')","if f''{info_lineas[0]}','{info_lineas[1]}','{info_lineas[2]}','{info_lineas[3]}'\n' != ''','','',''\n':","lineas_a_grabar[1].append(f''{info_lineas[0]}','{info_lineas[1]}','{info_lineas[2]}','{info_lineas[3]}'\n')","if cadenas[0] != '':","lineas_a_grabar[0].append(cadenas[0]+'\n')","return lineas_a_grabar, lineas_fuera_funcion"
"longitud_maxima","(columnas_datos, longitud)","m_obtener.py","for elemento in range(len(columnas_datos)):","if len(columnas_datos[elemento]) > longitud[elemento]:","longitud[elemento] = len(columnas_datos[elemento])","return longitud"
"*main","()","*main.py","csv_finales.crear_csv_finales('programas.txt')","datos_por_funciones, datos_por_autores = obtener_datos_csv('fuente_unico.csv', 'comentarios.csv')","for funcion in datos_por_funciones:","print(f'{funcion}.{datos_por_funciones[funcion]['modulo']} - {datos_por_funciones[funcion]['invocaciones']}')","menu_interaccion(datos_por_funciones, datos_por_autores)"
"maxima_longitud","(lista_funciones)","m_obtener.py","return len(max(lista_funciones, key=len))"
"menu_interaccion","(datos_por_funciones, datos_por_autores)","*main.py","mostrar_menu_interaccion()","opcion = input('Ingrese una opcion o presione ENTER para salir: ')","print()","while opcion:","if opcion == '1' or opcion.lower() == 'panel general de funciones':","panel_general_funciones.obtener_panel_general(datos_por_funciones)","mostrar_menu_interaccion()","elif opcion == '2' or opcion.lower() == 'consultar funciones':","consulta_funciones.consultar_funciones(datos_por_funciones)","mostrar_menu_interaccion()","elif opcion == '3' or opcion.lower() == 'analizar reutilizacion de codigo':","analizador_reutilizacion_codigo.analizar_reutilizacion(datos_por_funciones)","mostrar_menu_interaccion()","elif opcion == '4' or opcion.lower() == 'arbol de invocaciones':","arbol_invocacion.grafica_arbol_invocaciones(datos_por_funciones)","mostrar_menu_interaccion()","elif opcion == '5' or opcion.lower() == 'informacion de desarrollador':","informacion_desarrollador.obtener_informacion_desarrollador(datos_por_autores)","mostrar_menu_interaccion()","elif opcion == '6' or opcion.lower() == 'ayuda':","mostrar_ayuda_menu(opcion)","mostrar_menu_interaccion()","else:","print('Opcion incorrecta!, intente denuevo...')","print()","opcion = input('Ingrese una opcion o presione ENTER para salir: ')","print()"
"merge","(nombre_archivo_final, archivos_individuales, lineas_fuera_funcion)","m_csv_finales.py","archivos_individuales = abrir_csv_individuales(archivos_individuales)","archivo_final= open(nombre_archivo_final, 'w')","grabar_csv_final_ordenado(archivo_final, archivos_individuales, lineas_fuera_funcion)","cerrar_csv_individuales(archivos_individuales)","archivo_final.close()"
"mostrar_ayuda_menu","(opcion)","*main.py","titulo = 'AYUDA DE OPCIONES'","print(f'{'*' * len(titulo)}\n{titulo}\n{'*' * len(titulo)}')","print(f'(1) - Muestra en pantalla, una tabla con la cantidad de declaraciones de la aplicacion (for, if/elif, break, exit, while, for); también genera el archivo “panel_general.csv” con esta informacion.')","print(f'(2) - Muestra en pantalla una tabla con todas las funciones de la aplicacion y se deja a merced del usuario consultar sobre ellas, o genera un archivo con esta informacion')","print(f'(3) - Muestra en pantalla una tabla con el analisis de la reutilzacion de codigo, y genera un archivo de texto con la misma')","print(f'(4) - Muestra en pantalla un arbol de invocacion de funciones')","print(f'(5) - Muestra en pantalla la informacion de cada autor que trabajo en la aplicacion, pudiendose apreciar las funciones que desarrollo, la cantidad de lineas de codigo de esa funcion y al final de cada autor un porcentaje de lineas de codigo escritas relativo a toda la aplicacion')","return input('Presione cualquier tecla para volver al menu')"
"mostrar_datos_funcion","(datos_csv, funcion, opcion)","m_consulta_funciones.py","if '#' in opcion:","informacion = formatear_datos_numeral(datos_csv, funcion)","print(informacion)","elif '?' in opcion:","informacion = formatear_datos_pregunta(datos_csv, funcion)","print(informacion)"
"mostrar_instrucciones_uso","()","m_consulta_funciones.py","print('?<funcion> ---> indica la descripcion asociada al uso, parametros, autor, y modulo de la funcion')","print('?todo ---> indica la descripcion asociada al uso, parametros, autor, y modulo de todas las funciones')","print('imprimir ?todo ---> lo mismo que ?todo pero lo graba en un archivo')","print('#<funcion> ---> indica todo lo relativo a la funcion')","print('#todo ---> indica todo lo relativo a todas las funciones')","print('imprimir #todo ---> lo mismo que #todo pero lo graba en un archivo')"
"mostrar_menu_interaccion","()","*main.py","titulo = 'ANALIZADOR Y EVALUADOR DE DISEÑO MODULAR DE APLICACIONES'","print(f'\n{'*' * len(titulo)}\n{titulo}\n{'*' * len(titulo)}')","print('1. Panel General de Funciones')","print('2. Consultar Funciones')","print('3. Analizar Reutilizacion de Codigo')","print('4. Arbol de Invocaciones')","print('5. Informacion de Desarrollador')","print('6. Ayuda')"
"mostrar_panel_general","(lista_de_listas, longitud)","m_panel_general_funciones.py","for lista in range(len(lista_de_listas)):","for elemento in range(len(lista_de_listas[lista])):","lista_de_listas[lista][elemento] += (' ' * (longitud[elemento] - len(lista_de_listas[lista][elemento])))","print('\t'.join(lista_de_listas[lista]))"
"mostrar_participacion","(datos)","m_informacion_desarrollador.py","print(datos)"
"mostrar_tabla_funciones","(tabla, cantidad_guiones)","m_consulta_funciones.py","print(f'{'-' * (cantidad_guiones)}')","print(tabla)","print(f'{'-' * (cantidad_guiones)}')"
"obtener_arbol_invocaciones","(diccionario_informacion, funcion = None, string = '')","m_arbol_invocacion.py","if funcion == None:","funcion = encontrar_main_archivo(diccionario_informacion)","str_invocacion = f'{string}---> {funcion.lstrip('*')}({diccionario_informacion[funcion]['cantidad_lineas']})'","else:","str_invocacion = f'{string} ---> {funcion}({diccionario_informacion[funcion]['cantidad_lineas']})'","invocaciones = diccionario_informacion[funcion]['invocaciones']","if len(invocaciones) == 0:","print(str_invocacion)","else:","for invocacion_de_funcion in range(len(invocaciones)):","if invocaciones[invocacion_de_funcion] == funcion:","print(f'{' ' * len(str_invocacion)} ---> {invocaciones[invocacion_de_funcion]}({diccionario_informacion[funcion]['cantidad_lineas']})')","elif invocacion_de_funcion == 0:","obtener_arbol_invocaciones(diccionario_informacion, invocaciones[invocacion_de_funcion], str_invocacion)","else:","obtener_arbol_invocaciones(diccionario_informacion, invocaciones[invocacion_de_funcion], ' ' * len(str_invocacion))"
"obtener_datos_csv","(fuente, comentarios)","*main.py","with open(fuente, 'r') as archivo_fuente, open(comentarios, 'r') as archivo_comentarios:","datos_por_funciones, datos_por_autores = organizar_datos.leer_archivos_csv(archivo_fuente, archivo_comentarios)","return datos_por_funciones, datos_por_autores"
"obtener_informacion_desarrollador","(datos_archivos_csv)","m_informacion_desarrollador.py","datos_ordenados = ordenar_diccionario_autores(datos_archivos_csv)","datos_formateados = formatear_participacion(datos_ordenados)","mostrar_participacion(datos_formateados)","crear_participacion_txt('participacion.txt', datos_formateados)"
"obtener_panel_general","(datos_archivos_csv)","m_panel_general_funciones.py","lista_de_listas, longitud = generar_tabla_panel_general(datos_archivos_csv)","crear_panel_general_csv(lista_de_listas)","mostrar_panel_general(lista_de_listas, longitud)"
"opcion_numeral","(datos_csv, opcion)","m_consulta_funciones.py","if opcion == '#todo':","for funcion in datos_csv:","mostrar_datos_funcion(datos_csv, funcion, opcion)","elif opcion[1:] in datos_csv.keys():","mostrar_datos_funcion(datos_csv, opcion[1:], opcion)","else:","print('Esa funcion no existe')"
"opcion_pregunta","(datos_csv, opcion)","m_consulta_funciones.py","if opcion == '?todo':","for funcion in datos_csv:","mostrar_datos_funcion(datos_csv, funcion, opcion)","elif opcion[1:] in datos_csv.keys():","mostrar_datos_funcion(datos_csv, opcion[1:], opcion)","else:","print('Esa funcion no existe')"
"ordenar_diccionario_autores","(datos_csv)","m_informacion_desarrollador.py","return sorted(datos_csv.items(), key=lambda x: x[1]['lineas_totales'], reverse=True)"
"porcentaje_lineas_codigo","(autor, datos_autor, lineas_codigo_totales)","m_obtener.py","return (datos_autor['lineas_totales'] / lineas_codigo_totales) * 100"
"resetear_por_fin","(linea_codigo, lineas_a_grabar, cadenas, banderas, info_lineas)","m_csv_individuales.py","banderas[0] = banderas[1] = banderas[2] =  False","cadenas[0] += f','{linea_codigo.strip()}''","lineas_a_grabar[0].append(cadenas[0]+'\n')","lineas_a_grabar[1].append(f''{info_lineas[0]}','{info_lineas[1]}','{info_lineas[2]}','{info_lineas[3]}'\n')","cadenas[0] = cadenas[1] = info_lineas[0] = info_lineas[1] = info_lineas[2] = info_lineas[3] = ''","return lineas_a_grabar, cadenas, banderas, info_lineas"
"resetear_por_inicio","(linea_codigo, nombre_modulo, lineas_a_grabar, cadenas, banderas, info_lineas, info_ubicaciones)","m_csv_individuales.py","banderas[1] = banderas[2] =  False","lineas_a_grabar[0].append(cadenas[0]+'\n')","lineas_a_grabar[1].append(f''{info_lineas[0]}','{info_lineas[1]}','{info_lineas[2]}','{info_lineas[3]}'\n')","cadenas[0] = cadenas[1] = info_lineas[1] = info_lineas[2] = info_lineas[3] = ''","info_lineas[0], param = analizar_linea.declaracion_funcion(linea_codigo)","if nombre_modulo == info_ubicaciones[0][1]:","cadenas[0] += f''{info_lineas[0]}','{param}','*{nombre_modulo}''","else:","cadenas[0] += f''{info_lineas[0]}','{param}','{nombre_modulo}''","return lineas_a_grabar, cadenas, banderas, info_lineas"
"solicitar_ingreso_usuario","(datos_csv)","m_consulta_funciones.py","print('\nPresion ENTER para salir')","opcion = input('\nFuncion: ')","while opcion:","analizar_opcion(datos_csv, opcion)","print('\nPresion ENTER para salir')","opcion = input('\nFuncion: ')"
"tabla_funciones","(lista_funciones, primera_fila = True)","m_obtener.py","cantidad_guiones = 0","longitud_maxima_funcion = maxima_longitud(lista_funciones)","tabla = ''","for i in range(len(lista_funciones)):","if (i % 5 == 0) and (i != 0):","tabla += '|\n'","if primera_fila:","cantidad_guiones = len(tabla)","primera_fila = False","separacion = ' ' * (longitud_maxima_funcion-len(lista_funciones[i]))","fila = f'| {lista_funciones[i]}(){separacion}'","tabla += fila","tabla += '|'","return tabla, cantidad_guiones"
"ubicaciones_archivos_csv_individuales","(nombres_archivos_csv_individuales)","m_obtener.py","return [os.path.abspath(nombre_archivo_csv_individual) for nombre_archivo_csv_individual in nombres_archivos_csv_individuales]"
